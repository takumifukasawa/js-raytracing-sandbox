<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>in-one-weekend</title>
  <style>
    * {
      margin: 0;
      padding: 0;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas class="js-canvas"></canvas>

  <script>
    const CANVAS_WIDTH = 200;
    const CANVAS_HEIGHT = 200;

    class AbstractGLObject {
      #gpu

      constructor({ gpu }) {
        this.#gpu = gpu;
      }
      getGLContext() {
        return this.#gpu.gl;
      }
      getGLObject() {
        throw "should implement method";
      }
    }

    class GPU {
      #gl;

      get gl() {
        return this.#gl;
      }

      constructor({ canvas }) {
        const gl = canvas.getContext('webgl2');
        this.#gl = gl;
      }

      clear() {
        const gl = this.gl;
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);
      }

      // TODO: pass scene
      render({ meshes }) {
        const gl = this.gl;
        for(let i = 0; i < meshes.length; i++)  {
          const mesh = meshes[i];
          const { shader, geometry, primitiveType } = mesh;
          const program = shader.getGLObject();
          const vertexArrayObject = geometry.vertexArrayObject.getGLObject();
          const indices = geometry.indices;
          gl.useProgram(program);
          gl.bindVertexArray(vertexArrayObject);
          if(indices) {
            gl.drawElements(primitiveType, indices.length, gl.UNSIGNED_SHORT, 0);
          } else {
            // TODO: primitive type に応じて vertexcount 調整
            gl.drawArrays(primitiveType, 0, geometry.vertexCount);
          }
        }
        gl.flush();
      }
    }

    class Shader extends AbstractGLObject {
      #program;

      getGLObject() {
        return this.#program;
      }

      constructor({ gpu, vertexShaderText, fragmentShaderText }) {
        super({ gpu });

        const gl = this.getGLContext();

        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vertexShaderText);
        gl.compileShader(vertexShader);
        const vertexShaderInfoLog = gl.getShaderInfoLog(vertexShader);
        if(vertexShaderInfoLog.length > 0) {
          throw vertexShaderInfoLog;
        }

        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fragmentShaderText);
        gl.compileShader(fragmentShader);
        const fragmentShaderInfoLog = gl.getShaderInfoLog(fragmentShader);
        if(fragmentShaderInfoLog.length > 0) {
          throw fragmentShaderInfoLog;
        }

        const program = gl.createProgram()
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program)
        const programInfoLog = gl.getProgramInfoLog(program);
        if(programInfoLog.length > 0) {
          throw programInfoLog;
        }

        this.#program = program;
      }
    }

    class VertexBufferObject extends AbstractGLObject {
      #vbo;

      getGLObject() {
        return this.#vbo;
      }

      constructor({ gpu, location, data, stride }) {
        super({ gpu });
        const gl = this.getGLContext();
        this.#vbo = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.#vbo);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(location);
        gl.vertexAttribPointer(location, stride, gl.FLOAT, false, 0, 0);
      }

      unbind() {
        const gl = this.getGLContext();
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
      }
    }

    class VertexArrayObject extends AbstractGLObject {
      #vao;
      #attributes

      getGLObject() {
        return this.#vao;
      }

      constructor({ gpu, attributes }) {
        super({ gpu });

        const gl = this.getGLContext();
        this.#vao = gl.createVertexArray();

        this.bind();

        for(let i = 0; i < attributes.length; i++) {
          const attribute = attributes[i];

          const { stride, data } = attribute;
          const location = attribute.location || i;

          const vbo = new VertexBufferObject({
            gpu, data, location, stride
          });
          vbo.unbind();
        }
      }

      bind() {
        const gl = this.getGLContext();
        gl.bindVertexArray(this.#vao);
      }

      unbind() {
        const gl = this.getGLContext();
        gl.bindVertexArray(null);
      }
    }

    class IndexBufferObject extends AbstractGLObject {
      #indexBufferObject;
      #indices;

      constructor({ gpu, indices }) {
        super({ gpu });

        this.#indices = indices;

        const gl = this.getGLContext();
        this.#indexBufferObject = gl.createBuffer();

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.#indexBufferObject);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Int16Array(indices), gl.STATIC_DRAW);
      }

      unbind() {
        const gl = this.getGLContext();
        gl.bindVertexArray(null);
      }
    }

    class Geometry {
      #vertexArrayObject;
      #indexBufferObject;
      #attributes;
      #indices;

      get vertexArrayObject() {
        return this.#vertexArrayObject;
      }

      get indices() {
        return this.#indices;
      }

      constructor({ gpu, attributes, indices }) {
        const gl = gpu.gl;

        this.#attributes = attributes;

        this.#vertexArrayObject = new VertexArrayObject({ gpu, attributes });

        if(indices) {
          this.#indices = indices;
          this.#indexBufferObject = new IndexBufferObject({ gpu, indices });
        }

        // unbinds
        this.#vertexArrayObject.unbind();
        if(this.#indexBufferObject) {
          this.#indexBufferObject.unbind();
        }
      }

      get vertexCount() {
        const attribute = this.attributes[0];
        return attribute.data.length / attribute.stride;
      }
    }

    class Texture extends AbstractGLObject {
      #texture;
      #img;

      static WrapType = {
        ClampToEdge: "ClampToEdge",
        Repeat: "Repeat"
      }

      getGLObject() {
        return this.#texture;
      }

      constructor({
        gpu,
        img,
        width,
        height,
        mipmap = true,
        wrapS = Texture.WrapType.ClampToEdge,
        wrapT = Texture.WrapType.ClampToEdge,
        flipY = true
      }) {
        super({ gpu });

        this.#img = img;

        const gl = this.getGLContext();

        this.#texture = gl.createTexture();

        gl.bindTexture(gl.TEXTURE_2D, this.#texture);

        if(this.#img) {
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, !!flipY);
        }

        if(width && height) {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.#img);
        } else {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.#img);
        }

        if(mipmap) {
          gl.generateMipmap(gl.TEXTURE_2D);
        }

        // TODO: specify filter
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

        switch(wrapS) {
          case Texture.WrapType.Repeat:
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            break;
          case Texture.WrapType.ClampToEdge:
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            break;
        }

        switch(wrapT) {
          case Texture.WrapType.Repeat:
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
            break;
          case Texture.WrapType.ClampToEdge:
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            break;
        }

        // TODO: unbind
      }

      setSize(width, height) {
        const gl = this.getGLContext();
        gl.bindTexture(gl.TEXTURE_2D, this.#texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.#img);
      }
    }

    class Renderbuffer extends AbstractGLObject {
      #renderbuffer;

      static Type = {
        Depth: "Depth",
      };

      getGLObject() {
        return this.#renderbuffer;
      }      

      constructor({ gpu }) {
        super({ gpu });

        const gl = this.getGLContext();

        this.#renderbuffer = gl.createRenderbuffer();
        
        gl.bindRenderbuffer(gl.RENDERBUFFER, this.#renderbuffer);
      }

      setSize(width, height) {
        const gl = this.getGLContext();

        gl.bindRenderbuffer(gl.RENDERBUFFER, this.#renderbuffer);
      }

      bind() {
        const gl = this.getGLContext();

        gl.framebufferRenderbuffer(
          gl.FRAMEBUFFER,
          gl.DEPTH_ATTACHMENT,
          gl.RENDERBUFFER,
          this.getGLObject()
        );
      }

      unbind() {
        const gl = this.getGLContext();

        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
      }
    }

    class Framebuffer extends AbstractGLObject {
      #framebuffer;

      getGLObject() {
        return this.#framebuffer;
      }

      constructor({ gpu }) {
        super({ gpu });

        this.#framebuffer = gl.createFramebuffer();

        gl.bindFramebuffer(gl.FRAMEBUFFER, this.#framebuffer);
      }
    }

    class RenderTarget {
      #texture;
      #framebuffer;
      #depthRenderbuffer;

      get texture() {
        return this.#texture;
      }

      get framebuffer() {
        return this.#framebuffer;
      }

      get depthRenderbuffer() {
        return this.#depthRenderbuffer;
      }

      constructor({
        gpu,
        width = 1,
        height = 1,
        useDepth = true
      }) {
        const gl = gpu.getGLContext();

        this.#framebuffer = new Framebuffer({ gpu });

        if(useDepth) {
          this.#depthRenderbuffer = new Renderbuffer({
            gpu,
            width,
            height,
            type: Renderbuffer.Type.Depth
          });
        }

        if(this.#depthRenderbuffer) {
          this.#depthRenderbuffer.bind();
        }

        this.#texture = new Texture({
          gpu,
          width: 1,
          height: 1,
          mipmap: false,
          flipY: true,
        });

        gl.framebufferTexture2D(
          gl.FRAMEBUFFER,
          gl.COLOR_ATTACHMENT0,
          gl.TEXTURE_2D,
          this.#texture.getGLObject()
        );

        gl.bindTexture(gl.TEXTURE_2D);

        if(this.#depthRenderbuffer) {
          this.#depthRenderbuffer.unbind();
        }

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      }

      setSize(width, height) {
        this.#texture.setSize(width, height);
        if(this.#depthRenderbuffer) {
          this.#depthRenderbuffer.setSize(width, height);
        }
      }
    }

    class Mesh {
      shader;
      geometry;
      primitiveType;
      constructor({ shader, geometry, primitiveType }) {
        this.shader = shader;
        this.geometry = geometry;
        this.primitiveType = primitiveType;
      }
    }

    const main = () => {
      const canvas = document.querySelector(".js-canvas");

      canvas.width = CANVAS_WIDTH;
      canvas.height = CANVAS_HEIGHT;

      const gpu = new GPU({
        canvas,
      });

      const vertexShaderText = `#version 300 es
        layout(location = 0) in vec3 aPosition;
        layout(location = 1) in vec2 aUv;
        out vec2 vUv;
        void main() {
          vUv = aUv;
          gl_Position = vec4(aPosition, 1.);
        }
      `;

      const fragmentShaderText = `#version 300 es
        precision mediump float;
        in vec2 vUv;
        out vec4 outColor;
        void main() {
          outColor = vec4(vUv, 0., 1.);
        }
      `;

      const fullQuadShader = new Shader({
        gpu,
        vertexShaderText,
        fragmentShaderText,
      });

      // 0 -------- 3
      // |          |
      // |          |
      // |          |
      // |          |
      // 1 -------- 2
      const fullQuadGeometry = new Geometry({
        gpu,
        attributes: [
          {
            name: 'position',
            data: [
              -1.0, 1.0, 0.0,                
              -1.0, -1.0, 0.0,                
              1.0, -1.0, 0.0,                
              1.0, 1.0, 0.0,                
            ],
            stride: 3
          },
          {
            name: 'uv',
            data: [
              0.0, 0.0,
              0.0, 1.0,
              1.0, 1.0,
              1.0, 0.0,
            ],
            stride: 2
          },
        ],
        indices: [
          0, 1, 2,
          2, 3, 0
        ]
      });

      const fullQuadMesh = new Mesh({
        shader: fullQuadShader,
        geometry: fullQuadGeometry,
        primitiveType: gpu.gl.TRIANGLES
      });

      const tick = (time) => {
        gpu.clear();
        gpu.render({ meshes: [ fullQuadMesh ]});
        requestAnimationFrame(tick);
      }

      requestAnimationFrame(tick);
    }

    main();

  </script>
</body>
</html>